#This file tells how enqueuer should be executed

#execution mode
#two modes are mutually exclusive. At least one of them has to be defined.:
# single-run: executes a single time. This is the one that has to be used when your goal is to integrate your pipeline.
# daemon: it will run indefinitely. Endlessly. As a service.
#         When running in daemon mode it will be waiting for test values (/docs/tests/test.yml) from those mechanisms inputs listed. One after the other.
#         Every supported IPC protocol is available here and you can check their values in /docs/tests/subscriptions folder.
run-mode:
  daemon:
    #Receives test from uds connections
    - type: uds
      path: /tmp/inUnix.sock
    #Receives test from tcp connections
    - type: tcp
      port: 23075
    #Receives test from mqtt connections
    - type: mqtt
      brokerAddress: mqtt://localhost:1883
      topic: enqueuer/input

#Optional. Defines how information are logged in the console. Accepted values are: trace; debug; info; warning (default); error; and fatal.
log-level: trace

#Optional. A single file for each input is generated and every test of it will be there.
#Every supported IPC protocol is available here and you can check their values in /docs/tests/publishers folder.
outputs:
  -
    type: file
    filenamePrefix: outputExamples/
    filenameExtension: yml #json

#Optional
store:
  #Variables keys and its variable value
  #Below, a 'tcpKey' key is defined with the value 'tcp value'.
  #there are two ways of using it:
  #   Non js code snippet: the easiest one is to type <<tcpKey>> where you want it to be replaced in a test file.
  #   js code snippet: simply store.tcpKey. So, if you type console.log(store.tcpKey) you'l see 'tcp value' being printed out in the console.
  tcpKey: "tcp value"
  #We can have as many definitions as you want to. You can even define whole objects here:
  object:
    first: first value
    second:
      nested: thing